;*************************************************************************************************
;CODE OWNERSHIP AND DISCLAIMER OF LIABILITY
;
;Microchip Technology Incorporated ("Microchip") retains all ownership and intellectual property rights in the code accompanying 
;this message and in all derivatives hereto.  You may use this code, and any derivatives created by any person or entity by or on 
;your behalf, exclusively with Microchip’s proprietary products.  Your acceptance and/or use of this code constitutes agreement to 
;the terms and conditions of this notice.
;
;CODE ACCOMPANYING THIS MESSAGE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR 
;STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS 
;FOR A PARTICULAR PURPOSE APPLY TO THIS CODE, ITS INTERACTION WITH MICROCHIP’S PRODUCTS, COMBINATION WITH ANY 
;OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
;
;YOU ACKNOWLEDGE AND AGREE THAT, IN NO EVENT, SHALL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT 
;(INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR 
;ANY INDIRECT, SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY 
;KIND WHATSOEVER RELATED TO THE CODE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY 
;OR THE DAMAGES ARE FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
;CLAIMS IN ANY WAY RELATED TO THIS CODE, SHALL NOT EXCEED THE PRICE YOU PAID DIRECTLY TO MICROCHIP SPECIFICALLY TO
;HAVE THIS CODE DEVELOPED.
;
;You agree that you are solely responsible for testing the code and determining its suitability.  Microchip has no obligation to modify, 
;test, certify, or support the code.
;***************************************************************************************************
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; MICROCHIP CODE HOPPING ENCODER
; For PIC16F636
; with pull-ups of pull-downs on switch inputs
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; VERSION 1.3:
;
;   Modified exclusively for use with PIC16F636  Jan 2008
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
;         This code mimics the functionality of a HCS dual encoder.
;         This source code requires the following files:
;		KLQ_PIC16F636.asm :  This file, is the main routine that sets up the information
;							to be encrypted and transmits it
;		encrypt.inc :			Source code for data encryption
;		CounterCode.inc :		Rolling counter code
;		KLQ_eeprom : 		Eeprom data setup, includes the registers to setup 
;							the transmission format
;
;         Assembler: MPASM
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

;---------------------------------------------------------------------------
; Conditional assembly options

; Select PORTA pushbuttons to be connected to ground with internal pull-ups
; OR, connected to VCC with internal pull-downs
;#DEFINE pullup 1	; Set to select pull-ups on PORT A. For pull-downs, comment out

;---------------------------------------------------------------------------
 page
	LIST R=DEC


	processor P16F636
	#include P16F636.INC
	#define ROMend 0x7FF
	#include TX_eeprom.inc

	__CONFIG _MCLRE_OFF & _INTRC_OSC_NOCLKOUT & _WDT_OFF & _WUREN_ON & _CP_OFF & _CPD_OFF

      	ERRORLEVEL 0, -205,-224,-302,-305,-306	
       						; Message, Warning and Error Printed
							; Ignore [224] => Use Of This Instruction is not recommended
                        				; Ignore [302] => Register in operand not in bank 0. 
                        				; Ignore [306] => Crossing page boundary - ensure ...

ON	EQU	1
OFF	EQU	0

page
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; REGISTER Bank 0: 				
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

; GENERAL PURPOSE REGISTERS
; GLOBAL WORK REGISTERS 

	cblock	0x58

	TX_CFG0			; TRANSMITTER CONFIGURATION BYTE #0
	BUTTON			; CURRENT BUTTON VALUE,
	CNT0			; LOOP COUNTER #0
	CNT1			; LOOP COUNTER #1
	CNT2			; LOOP COUNTER #2
	TX_CFG1			; TRANSMITTER CONFIGURATION BYTE #1
	SYSCFG0			; SYSTEM CONFIGURATION BYTE #0
	SYSCFG1			; SYSTEM CONFIGURATION BYTE #1

	B_MASK			; BUTTON MASK REGISTER
	CRC				; MSB AND LSB OF CRC REGISTER
	QUEUE			; QUEUE BIT COUNTER 

	CLK_50			; 50ms EVENT CLOCK COUNTER
	CLK_HI			; OVERFLOW FOR CLK_50 COUNTER
	CLK_LED			; LED TIMEOUT COUNTER
	TEMP			; TEMPORARY STORAGE SPACE

	CSR5			; FALLING EDGE BUTTON DEBOUNCE REUSED FOR LFTE
	CSR6			; TRANSMISSION BITS REUSED TO MEASURE LF BIT WIDTHS
	COMP			; TE COMPENSATION VALUE
	CNT3			; LOOP COUNTER #3

	ButtonImage		; Real button positions
	endc

	cblock	0x70		;Shared Bank0-1-2-3 addresses
	VLOWLEVEL 		; TEMP LOCATION TO STORE EEPROM VLOW LATCH SETTING
	FLAGS			; USER FLAG REGISTER
	TX_INDEX			; INDICATE WHICH TRANSMITTER TO USE
	endc

	cblock	0x78
	NSR0			; KEELOQ ALGORTIHM CODE SHIFT REGISTERS 
	NSR1			; KEELOQ ALGORTIHM CODE SHIFT REGISTERS
	NSR2			; KEELOQ ALGORTIHM CODE SHIFT REGISTERS
	NSR3			; KEELOQ ALGORTIHM CODE SHIFT REGISTERS
	NSR4			; KEELOQ ALGORTIHM KEY REGISTER
	NSR5			; TRANSMISSION SHIFT REGISTER
	NSR6			; TRANSMISSION SHIFT REGISTER
	NSR7			; TRANSMISSION SHIFT REGISTER
	endc

	#define	COUNTA	NSR5		; COUNTER BITS 21-16 MSB
	#define	COUNTB	NSR4		; COUNTER BITS 15-8
	#define	COUNTC	NSR3		; COUNTER BITS 7-0 LSB
	#define	CHECKBC	NSR2		; B XOR C CHECKSUM
	#define	CHECKAB	NSR1		; A XOR B CHECKSUM
	#define	CHECKAC	NSR0		; A XOR C CHECKSUM

page
; ********* PORT BIT DEFINITIONS **************************
;                 +------------+
;           Vdd   | 1       14 | Vss
;           S0    | 2       13 | LED1n
;           S1    | 3       12 | DATA                          PIC16F636
;           S2    | 4       11 | S3/SHIFT/RFEN
;           RC5   | 5       10 | RC0 (user)
;           LED2n | 6        9 | RC1 (user)
; (user)    RC3   | 7        8 | RC2 (user)
;                 +------------+
	
	#define	S1			PORTA,4		; S1 BUTTON INPUT
	#define	S2			PORTA,0		; S2 BUTTON INPUT
	#define	S3			PORTA,1		; S3 BUTTON INPUT This is also the alternate transmitter (SHIFT) button
	#define	S4			PORTA,2		; S0 BUTTON INPUT	
	#define	RFOUT		PORTA,5		; S4 BUTTON INPUT

	#define	LED1		PORTC,4
	#define	LED2		PORTC,3
	#define	LED3		PORTC,1
	#define	LED4		PORTC,0

	#DEFINE	RFEN		PORTA,2		; RF ENABLE OUTPUT
	#DEFINE	RFENtris	TRISA,2
	#DEFINE	SHIFT		PORTA,2		; SHIFT BUTTON INPUT


; ********* I/O PORT TRI-STATE VALUES **********************

RA_TRIS	EQU	B'00010111'
RC_TRIS	EQU	B'00000000'


page
	#define 	VLOW	PIR1,LVDIF		; LOW VOLTAGE INDICATION BIT

; ***** TRANSMITTER FLAGS BIT DEFINITIONS ***************

VLOWBAT		EQU	0H		; INDICATE VOLTAGE LOW STATE
BUT_REL			EQU	1H		; INDICATE BUTTON RELEASED
DO_GUARD 		EQU	2H		; INDICATE A GUARD TIME DELAY IS REQUIRED
TX_NUM			EQU	3H		; INDICATE WHICH TRANSMITTER TO USE
FIRST			EQU	4H		; INDICATE THAT THE FIRST EVENT COMPLETED
SEEDNOW		EQU	5H		; INDICATE THAT WE SHOULD SEND THE SEED TX NOW
TEMPBIT			EQU	6H		; TEMPORARY INDICATION BIT
BUT_DWN		EQU	7H		; INDICATE THAT A NEW BUTTON WAS ADDED WHEN BIT = 0

; ****** TRANSMITTER CONFIGURATION BYTE #0 *****************

#DEFINE	MSEL0	TX_CFG0,0H	; TRANSMISSION MODULATION SELECT BIT #0
#DEFINE	MSEL1	TX_CFG0,1H	; TRANSMISSION MODULATION SELECT BIT #1
#DEFINE	HSEL	TX_CFG0,2H	; 4/10 Te HEADER SELECT BIT 
#DEFINE	XSER	TX_CFG0,3H	; EXTENDED SERIAL NUMBER ENABLE
#DEFINE	QUEN	TX_CFG0,4H	; QUEUING BITS ENABLE OPTION
#DEFINE	STRTSEL	TX_CFG0,5H	; START/STOP BIT SELECT BIT
#DEFINE	LEDL		TX_CFG0,6H	; BATTERY LOW LED STATE SELECT BIT
#DEFINE	LEDH	TX_CFG0,7H	; LED BLINK RATE SELECT BIT

; ****** TRANSMITTER CONFIGURATION BYTE #1 *****************

#DEFINE SDLM	TX_CFG1,0H	; LIMITED SEED TRANSMISSIONS (OFF/ON)
#DEFINE SDMD	TX_CFG1,1H	; SEED MODE (USER/PRODUCTION)
#DEFINE SDTM0	TX_CFG1,2H	; TIME BEFORE SEED TRANSMISSION (LSB)
#DEFINE SDTM1	TX_CFG1,3H	; TIME BEFORE SEED TRANSMISSION (MSB)
#DEFINE	BSL0	TX_CFG1,4H	; BAUD RATE SELECT BIT (LSB)
#DEFINE	BSL1	TX_CFG1,5H	; BAUD RATE SELECT BIT (MSB)
#DEFINE	GSEL0	TX_CFG1,6H	; GUARD TIME SELECT BIT #0
#DEFINE	GSEL1	TX_CFG1,7H	; GUARD TIME SELECT BIT #1

; ****** SYSTEM CONFIGURATION BYTE #0 **********************

#DEFINE	WSEL0	SYSCFG0,0H	; WAKEUP SELECT BIT #0
#DEFINE	WSEL1	SYSCFG0,1H	; WAKEUP SELECT BIT #1
#DEFINE	CNTSEL	SYSCFG0,2H	; 16/20 BIT COUNTER SELECT BIT
#DEFINE	VLOWL	SYSCFG0,3H	; VLOW LATCHED SELECT BIT
#DEFINE	VTRIP	SYSCFG0,4H	; VLOW TRIP POINT SELECT BIT
#DEFINE	PLLSEL	SYSCFG0,5H	; ASK/FSK PLL SELECTION BIT 

; ****** SYSTEM CONFIGURATION BYTE #1 **********************

#DEFINE	MTX0	SYSCFG1,0H	; MINIMUM NUMBER OF CODE WORD (LSB)
#DEFINE	MTX1	SYSCFG1,1H	; MINIMUM NUMBER OF CODE WORD (MSB)
#DEFINE	INDSEL	SYSCFG1,2H	; INDEPENDENT MODE SELECT BIT 
#DEFINE	RFENSEL	SYSCFG1,3H	; RF ENABLE MODE SELECT BIT 
#DEFINE	TSEL0	SYSCFG1,4H	; TIMEOUT SELECT BIT #0
#DEFINE	TSEL1	SYSCFG1,5H	; TIMEOUT SELECT BIT #1

; ***** TIME MEASUREMENT CONSTANT DEFINITIONS **************

T_50		EQU	D'1'			; TIME COUNTER VALUE FOR 50 ms
T_100		EQU	D'2'			; TIME COUNTER VALUE FOR 100 ms
T_200		EQU	D'4'			; TIME COUNTER VALUE FOR 200 ms
T_500		EQU	D'10'		; TIME COUNTER VALUE FOR 500 ms
T_800		EQU	D'16'		; TIME COUNTER VALUE FOR 800 ms
T_1000		EQU	D'20'		; TIME COUNTER VALUE FOR 1000 ms
T_1600		EQU	D'32'		; TIME COUNTER VALUE FOR 1.6 SECONDS
T_2400		EQU	D'48'		; TIME COUNTER VALUE FOR 2.4 SECONDS
T_3200		EQU	D'64'		; TIME COUNTER VALUE FOR 3.2 SECONDS
T_25600		EQU	D'4'			; TIME COUNTER VALUE FOR 25.6 SECONDS

; ***** EEPROM MEMORY MAP DEFINITIONS **********************

EE_CNT0		EQU	00H		; OFFSET FOR TX0'S EEPROM SYNC COUNTER
EE_CNT1		EQU	08H		; OFFSET FOR TX1'S EEPROM SYNC COUNTER
EE_CNT2		EQU	80H		; OFFSET FOR TX2'S EEPROM SYNC COUNTER
EE_CNT3		EQU	88H		; OFFSET FOR TX3'S EEPROM SYNC COUNTER

EE_VLOWL 	EQU	07H		; OFFSET FOR VLOW LATCH BYTE

A_EE_SER	EQU	10H		; OFFSET OF TX'S 64 BIT SEED VALUE			* FIRST TRANSMITTER *
A_EE_SEED	EQU	14H		; OFFSET OF TX'S 64 BIT SEED VALUE
A_EE_DISC	EQU	1CH		; OFFSET OF TX'S 16 BIT DISCRIMINATION VALUE
A_EE_KEY	EQU	1EH		; OFFSET OF TX'S 64 BIT ENCRYPTION KEY

B_EE_SER	EQU	26H		; OFFSET OF TX'S 64 BIT SEED VALUE 		* SECOND TRANSMITTER *
B_EE_SEED	EQU	2AH		; OFFSET OF TX'S 64 BIT SEED VALUE
B_EE_DISC	EQU	32H		; OFFSET OF TX'S 16 BIT DISCRIMINATION VALUE
B_EE_KEY	EQU	34H		; OFFSET OF TX'S 64 BIT ENCRYPTION KEY

C_EE_SER	EQU	90H		; OFFSET OF TX'S 64 BIT SEED VALUE			* THIRED TRANSMITTER *
C_EE_SEED	EQU	94H		; OFFSET OF TX'S 64 BIT SEED VALUE
C_EE_DISC	EQU	9CH		; OFFSET OF TX'S 16 BIT DISCRIMINATION VALUE
C_EE_KEY	EQU	9EH		; OFFSET OF TX'S 64 BIT ENCRYPTION KEY

D_EE_SER	EQU	0A6H		; OFFSET OF TX'S 64 BIT SEED VALUE 		* FOURTH TRANSMITTER *
D_EE_SEED	EQU	0AAH		; OFFSET OF TX'S 64 BIT SEED VALUE
D_EE_DISC	EQU	0B2H		; OFFSET OF TX'S 16 BIT DISCRIMINATION VALUE
D_EE_KEY	EQU	0B4H		; OFFSET OF TX'S 64 BIT ENCRYPTION KEY

EE_CFG3		EQU	3CH		; OFFSET OF 16 BIT TRANSMITTER CONFIGURATION WORD
EE_CFG2		EQU	3DH		; OFFSET OF 16 BIT TRANSMITTER CONFIGURATION WORD
EE_CFG1		EQU	3EH		; OFFSET OF 16 BIT TRANSMITTER CONFIGURATION WORD
EE_CFG0		EQU	3FH

EE_TX2_CFG1	EQU	0BCH
EE_TX3_CFG1	EQU	0BEH

EE_TX_INDEX	EQU 0FFH

page
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; RESET Vector address 000H
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
	ORG	000H

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; **************************************************************************
; FUNCTION     	: RESET ()	      			
; **************************************************************************
; DESCRIPTION  	: PROGRAM RESET ROUTINE
; **************************************************************************
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
RESET
	MOVLW	b'00000111'			; DISABLE ANALOG SECTIONS-->MOVE TO ALL DIGITIAL
	MOVWF	CMCON0	
	CLRF	PORTA
	CLRF	PORTC
	BSF		LED1					; TURN OFF LED
	BSF		LED2					; TURN OFF LED
	BSF		LED3					; TURN OFF LED
	BSF		LED4					; TURN OFF LED
	CLRF	TMR1L
	CLRF	TMR1H
	MOVLW	b'00110001'
	MOVWF	T1CON 
	BSF		STATUS,RP0			; BANK0--> RP0 = RP1 = 0
	MOVLW	RA_TRIS				; SETUP PORT A
	MOVWF	TRISA	
	MOVLW	RC_TRIS				; SETUP PORT C
	MOVWF	TRISC			; 
	MOVLW	b'01100001'			; INTERNAL 4 MHZ
	MOVWF	OSCCON
	MOVLW	b'01000110'			; SET UP FOR TMR0'S PRESCALER VALUE TO 128
								; (RAPU, bit7) = 0 TO ENABLE WEAK PULL-UP FOR 3 ALSO 
	MOVWF	OPTION_REG			; THIS IS USED FOR DELAY LOOP ONLY

	MOVLW	b'00111100'			; 
	MOVWF	WPUDA				; PULL-UP/PULL-DOWN ENABLE REGISTER
IFDEF pullup
	MOVLW	b'00110111'			; 
ELSE
	MOVLW	b'00000000'
ENDIF
	MOVWF	WDA				; PULL-UP/PULL-DOWN SELECTION DIRECTION REGISTER

	MOVLW	b'11111111'			; 
	MOVWF	IOCA				; ENABLE ALL RA PORT INDIVIDUAL PIN INTERUPT 
	BCF		STATUS,RP0

NEWBUTTON:

; ****** LOAD SYSTEM CONIGURATION FROM EEPROM *********************************

	GOTO	DEBOUNCER			; DEBOUNCE BUTTONS AND READ EEPROM OPTIONS

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; FUNCTION	: RFOUT_OFF()
;
; DESCRIPTION	: SWITCH RF OUT OFF AND CONTINUE TO WAIT FOR ONE RF Te
;
; PAGE		: 0
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
RFOUT_OFF
	INCF		COMP,F				; SHORTEN PULSE WIDTH
RFOUT_OFF3
	BCF		RFOUT				; SET RF OUTPUT LOW
	GOTO	TE_DELAY			; DO TE DELAY TIME


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; FUNCTION	: RFOUT_ON()
;
; DESCRIPTION	: SWITCH RF OUT ON AND CONTINUE TO WAIT FOR ONE RF Te
;
; PAGE		: 0
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
RFOUT_ON
	INCF		COMP,F				; SHORTEN PULSE WIDTH
RFOUT_ON3
	BSF		RFOUT				; SET RF OUTPUT HIGH
	GOTO	TE_DELAY			; DO TE DELAY TIME


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; FUNCTION	: TE_DELAY ()
;		  
; PARAMETER	: CNT2 EQUAL TO NUMBER OF 5US STEPS TO REMOVE FROM DELAY
;
; DESCRIPTION	: WAIT FOR 1 TE CYCLE AND FLASH LED AS REQUIRED
;
; RETURN	: SET ZERO FLAG IF ALL BUTTON RELEASED
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
TE_DELAYL
	INCF		COMP,F				; REMOVE 4 US COMPENSATION TIME
TE_DELAY
	CALL	TST_CLK				; UPDATE 50MS CLOCK
TE_DEL03
	CALL	TST_LED				; CHANGE LED PIN IF REQUIRED, RETURNS BAUD RATE AND C=0
TE_DEL05
	nop
	nop
	MOVWF	CNT2				; STORE BAUD RATE
	BTFSC	BSL0				; CHECK IF BSL0 BIT IS SET
	ADDWF	CNT2,F				; ... YES, THEN MULTIPLY BY 2

	MOVLW	D'14'				; MINIMUM COMPENSATION
	ADDWF	COMP,W				; ADD COMPENSATION FOR CALCULATION OVERHEAD
	SUBWF	CNT2,F				; SHORTEN BIT WIDTH BY COMPENSATION AMOUNT

	BTFSS	STATUS,C			; CHECK IF COMPENSATION IS MORE THAN LOOP COUNTER
	RETLW	0H					; ... YES, THEN SKIP TE DELAY LOOP
	CLRF	COMP				; CLEAR FOR NEXT BIT
TE_DEL10
	nop
	nop
	DECFSZ	CNT2,F				; [2/1] MORE LOOPS TO DO?
	GOTO	TE_DEL10			; [0/2] ... YES

; ***** CHECK BUTTONS ******************

TE_DEL30
IFDEF pullup
	comf	PORTA,w
ELSE
	MOVFW	PORTA				; [1/1] READ GENERAL I/O PORT
ENDIF
	ANDWF	B_MASK,W			; [1/1] MASK OUT THE BUTTON BITS
	movwf	ButtonImage
	BTFSC	STATUS,Z			; [2/1] CHECK ALL BUTTONS RELEASED ??
	DECFSZ	CSR5,F				; DEBOUNCE FALLING BUTTON EDGE
	GOTO	TE_DEL90
	BSF		FLAGS,BUT_REL		; [0/1] ... YES, THEN SET BUTTON RELEASED BIT
TE_DEL90
	COMF	BUTTON,W			; [1] INVERT BUTTON CODE
	ANDWF	ButtonImage,W		; [1] AND WITH WHATS ON THE PORT
	BTFSC	FLAGS,BUT_REL		; [2/1] CHECK IF BUTTON WAS RELEASED
IFDEF pullup
	comf	PORTA,w
ELSE
	MOVFW	PORTA				; [1/1] READ GENERAL I/O PORT
ENDIF
	ANDWF	B_MASK,W			; [1/1] MASK OUT THE BUTTON BITS
	movwf	ButtonImage
	BTFSC	STATUS,Z			; IF NO BUTTON WAS ADDED
	RETLW	0H					; ... THEN RETURN
	XORWF	BUTTON,W			; COMPARE THE NEW BUTTON PRESSED TO PREVIOUS ONE
	ANDWF	B_MASK,W			; ELIMINATE EXTRA BITS
	BTFSC	STATUS,Z			; IF IT WAS THE SAME
	BSF		BUTTON,7			; ... THEN SET THE DOUBLE BUTTON PRESS FLAG
	BTFSS	STATUS,Z			; OTHERWISE
	goto	NEWBUTTON

VLOW_DELAY
	RETLW	1H


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; FUNCTION	: TST_LED ()
;
; DESCRIPTION	: CHECK IF LED NEEDS TO TOGGLE, THEN TOGGLE IT, 20/21 CYCLES
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
TST_LED
	MOVFW	CLK_LED				; [1] GET NEXT LED TRANSITION TIME
	SUBWF	CLK_50,W			; [1] COMPARE WITH CURRENT TIME
	MOVLW	T_100				; [1] SET LED ON TIME FOR 100MS
	BTFSS	LEDH				; [1/2] IF LED BLINK SHOULD BLINK FASTER
	MOVLW	T_50				; [1/0] ... THEN SET LED ON TIME FOR 50MS
	BTFSS	LED1					; [1/2] IF LED IF OFF
	MOVLW	T_500				; [1/0] ... THEN SET LED OFF TIME
	BTFSS	STATUS,C			; [1/2] IF TIME TEST WAS LESS THAN TRIGGER
	GOTO	TST_LED2			; [2/0] ... THEN SKIP LED UPDATE

	ADDWF	CLK_50,W			; [1] CALCULATE NEXT TIME TO TOGGLE
	MOVWF	CLK_LED				; [1] STORE NEXT TIME TO TOGGLE
	MOVFW	PORTA				; [1] GET LED SETTING
	BTFSC	FLAGS,VLOWBAT		; [1/2] IF BATERY LEVEL IS LOW
	ANDLW	0FEH				; [1/0] THEN TURN LED OFF
	XORLW	1					; [1] ELSE TOGGLE LED
	MOVWF	PORTA				; [1] THEN UPDATE LED

TST_LED1
	BTFSS	BSL1				; [1/2] CHECK IF BSL1 BIT IS SET
	RETLW	D'20'				; [2] RETURN BAUD=100USEC AND CARRY=0
	RETLW	D'80'				; [2] RETURN BAUD=400USEC AND CARRY=0
								; TOTAL = [20] CYCLES WITH CALL

TST_LED2
	GOTO	$+1					; WASTE TIME TO KEEP BOTH PATHS EQUAL TIME
	GOTO	$+1					; CANNOT USE CALL BECAUSE STACK IS FULL
	GOTO	TST_LED1


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; FUNCTION	: TST_CLK ()
;
; DESCRIPTION	: UPDATE 50MS CLOCK AS REQUIRED, 19 CYCLES
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
TST_CLK
	MOVLW	18H				; 24x256x8 = 6144 x 8 = 49152 => 50MS
	BTFSC	CLK_50,0			; EVERY OTHER TEST DITHERS THE ERROR
	MOVLW	19H				; 24x256x8 = 6144 x 8 = 49152 => 50MS
	SUBWF	TMR1H,W		; COMPARE WITH REAL TIMER COUNTER
	BTFSC	STATUS,C		; IF TIMEOUT REACHED
	MOVWF	TMR1H			; ... THEN STORE RESULT IN RTCC
	BTFSC	STATUS,C		; IF TIMEOUT REACHED
	INCF		CLK_50,F			; ... THEN INCREMENT THE 50MS EVENT COUNTER
	BTFSS	CLK_50,7			; [2/1] CHECK IF MSB SET 
	GOTO	TST_CLK5		; [0/2] ... NO, THEN WASTE 2 CYCLES AND RETURN
	INCF		CLK_HI,F			; ... THEN INCREMENT 50MS OVERFLOW COUNTER
	BCF		CLK_50,7			; CLEAR MSB OF 50MS CLOCK COUNTER
	BCF		CLK_LED,7		; CLEAR MSB OF LED CLOCK COUNTER
	RETLW	D'54'			; RETURN START VALUE 200US DELAY
TST_CLK5
	RETLW	D'54'			; RETURN START VALUE 200US DELAY


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; FUNCTION	: DLY_200US ()
;
; DESCRIPTION	: WAIT FOR CNT1 x 200us DELAY, WHILE CHECKING BUTTON
;
; PAGE		: 0
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
DLY_200US
	MOVWF	CNT1		; STORE THE NUMBER OF MS DELAY REQUIRED
DLY_US2
	CALL	TST_LED		; UPDATE LED STATUS
	CALL	TST_CLK		; UPDATE 50MS CLOCK, RETURNS 120 FOR DELAY COUNTER 
DLY_3US
	MOVWF	CNT2		; LOAD INNER LOOP COUNTER
DLY_US3
	DECFSZ	CNT2,F		; ALL INNER LOOPS DONE ?
	GOTO	DLY_US3		; ... NO, THEN DO NEXT

	DECFSZ	CNT1,F		; ALL OUTER LOOPS DONE ?
	GOTO	DLY_US2		; ... NO, THE DO NEXT
	RETLW	0H



;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; FUNCTION	: 		TX_BITS ()
;
; DESCRIPTION	: 	SEND TRANSMISSION BITS OUT ON RFOUT PIN
;
; NOTES		: 		USE DOUBLE COUNTER SIZE TO MAKE BYTE ROLLOVER TEST EASIER
;		: 			MODIFY WITH EXTREME CAUTION TO PRESERVE BIT CALIBRATION
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
TX_BITH
	MOVLW	1			; SEND A LOGIC 1 BIT
TX_1BIT
	BSF		CNT1,1		; SET LENGTH = 1 WITHOUT MODIFING W *2
TX_BITW
	NOP
	GOTO	TX_BITWW	; EXTRA 2 CYCLE DELAY BEFORE SENDING BITS IN W
TX_BITS
	MOVWF	CNT1		; STORE LENGTH
	MOVLW	NSR0-1		; POINT TO FIRST BIT OF BUFFER WITHOUT PAGE BITS
	MOVWF	FSR			; THE PAGE BITS WILL BE INSERTED LATER
	
TX_BITL
	MOVLW	0EH			; GET MASK FOR BYTE ROLLOVER
	ADDWF	CNT1,W		; SET DC FLAG IF ROLLOVER
	BTFSS	STATUS,DC	; IF FIRST FULL BYTE OR BYTE ROLLOVER
 	INCF		FSR,F		; ... THEN POINT TO BYTE
	MOVFW	INDF			; GET NEXT BYTE
	BTFSS	STATUS,DC	; IF FIRST FULL BYTE OR BYTE ROLLOVER
TX_BITWW
	MOVWF	CSR6		; ... THEN STORE BYTE IN WORKING SPACE
	DECF	CRC,W		; DECREMENT IS SHORTCUT FOR CRC ALGORITHM:
	BTFSC	CRC,1		;  CRC[0]n+1 = CRC[1]n XOR CRC[0]n XOR Dn
	XORLW	3			;  CRC[1]n+1 = CRC[0]n XOR Dn
	MOVWF	CRC			; STORE FIRST HALF OF CRC CALCULATION
	BTFSS	CSR6,0		; IF BIT = 0
	COMF	CRC,F		; THEN INVERT CRC

	BTFSS	MSEL0		; IF MANCHESTER/PPM MODULATION NOT SELECTED
	GOTO	TX_WM		; ... THEN DO PWM/VPWM

TX_PPM
	GOTO	$+1			; EQUALIZE TIME FOR PREVIOUS GOTO + PWM TEST
	MOVFW	PORTA		; GET THE OTHER OUTPUT LEVELS
	ANDLW	0FDH		; MAKE RFOUT GO LOW
	BTFSC	CSR6,0		; IF TRANSMITTING A ONE
	IORLW	2			; MAKE RFOUT GO HIGH
	MOVWF	PORTA		; START BIT NOW
	CALL	TE_DELAYL	; DO 1 TE DELAY
	MOVFW	PORTA		; GET OUTPUT LEVEL
	XORLW	2			; TOGGLE OUTPUT
	MOVWF	PORTA		; MAKE CHANGE NOW

	BTFSS	MSEL1		; IF MANCHESTER MODULATION
	GOTO	TX_MAN		; ... THEN SKIP LAST PPM TE

	CALL	TE_DELAYL	; DO 1 TE DELAY
	BCF		RFOUT		; SET LAST TE OF PWM LOW
	NOP
	GOTO	$+1
TX_MAN
	GOTO	$+1
	BSF		COMP,2
	CALL	TE_DEL03	; DO 1 TE DELAY
	GOTO	TX_ROTATE

TX_WM
	BTFSS	MSEL1		; IF VPWM MODULATION NOT SELECTED
	GOTO	TX_PWM		; ... THEN DO PWM
TX_VPWM	
	NOP					; EQUALIZE TIME FOR PREVIOUS GOTO
	MOVFW	PORTA		; READ PORTA
	XORLW	2			; TOGGLE RF DATA OUT BIT
	MOVWF	PORTA		; OUTPUT NEW BIT
	BSF		COMP,2
	CALL	TE_DEL03	; DO TE DELAY TIME
	RRF		PORTA,W		; GET OUTPUT LEVEL INTO BIT 0
	XORWF	CSR6,W		; COMPARE TO THE TRANSMIT BIT
	ANDLW	1			; GET RID OF THE OTHER BITS
	BTFSS	STATUS,Z	; IF THE LEVEL IS OPPOSITE
	CALL	TE_DELAY	; ... THEN DO ANOTHER TE DELAY
	GOTO	TX_ROTATE	; IF NOT TOTALLY CONFUSED YET THEN ASK FOR A RAISE

TX_PWM
	GOTO	$+1
TX_PWM1
	BSF		RFOUT		; SET RF OUTPUT HIGH
	CALL	TE_DELAYL	; DO 1 TE DELAY
	NOP					; VERY CRITICAL TIME DELAYS TO MAKE ACCURATE PULSES
	BTFSC	CSR6,0		; IF TRANSMITTING A ONE
	BCF		RFOUT		; ... THEN SET MIDDLE TE OF PWM LOW
TX_PWM2
	GOTO	$+1
	CALL	TE_DELAYL	; DO 1 TE DELAY
TX_PWM3
	BCF		RFOUT		; SET LAST TE OF PWM LOW
	MOVLW	3
	MOVWF	COMP
	CALL	TE_DEL03	; DO 1 TE DELAY
	NOP
TX_ROTATE
	NOP
	RRF		CSR6,F		; ROTATE NEXT BIT INTO POSITION
	DECF	CNT1,F		; FIX FOR DOUBLED COUNT SIZE
	DECFSZ	CNT1,F		; ALL BITS TRANSMITTED? SET CLEAR PWM FLAG
	GOTO	TX_BITL		; ... NO, THEN DO NEXT BIT
	RETLW	0


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; FUNCTION     	: VLOW_LEVEL ()	      			
;
; DESCRIPTION  	: PICK THE VLOW LEVEL TO TEST BASED ON VTRIP FLAG AND LATCH
;
; PAGE		: 1
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
VLOW_LEVEL
	MOVLW		EE_VLOWL	; POINT VLOW LATCH
	CALL		EEREAD0		; READ BYTE FROM EEPROM
	BSF			STATUS,RP0
	INCF			EEDATA,W	; SET Z FLAG IF VLOW LATCH SET @ 0FFH
	BCF			STATUS,RP0	; SELECT RAM BANK #0
	MOVLW		HIGH $+8
	MOVWF		PCLATH
	MOVLW		2H			; PRELOAD OFFSET FOR LATCHED 3V LEVEL
	BTFSC		VTRIP		; IF VTRIP OPTION IS SET
	MOVLW		3H			; ... THEN USE THE OFFSET FOR LATCHED 5V LEVEL
	BTFSC		VLOWL		; IF VLOW VALUE SHOULD NOT BE LATCHED
	BTFSS		STATUS,Z	; . OR IT WAS NOT YET LATCHED
	ANDLW		1H			; ... THEN USE LOWER TEST LEVELS
	ADDWF		PCL,F		; ADD TO PROGRAM COUNTER
	RETLW		11H			; LOW VOLTAGE LEVEL = 2.0V
	RETLW		14H			; LOW VOLTAGE LEVEL = 2.3V
	RETLW		15H			; LOW VOLTAGE LEVEL = 4.0V
	RETLW		17H			; LOW VOLTAGE LEVEL = 4.5V


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; FUNCTION     	: TRANSMIT ()	      			
;
; DESCRIPTION  	: SEND TRANSMISSION OUT ON RFOUT PIN
;
; PAGE		: 0
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
TRANSMIT:
	CLRF	CRC				; CLEAR CRC HERE BECAUSE IT WAS A TIME WASTING NOP ANYWAY
	BTFSC	STRTSEL			; IF MANCHESTER/PPM START BIT REQUIRED
	BSF		CRC,0			; ... THEN BIAS CRC FOR START BIT

	BCF		FLAGS,TEMPBIT	; RESET LED STATE FLAG
	BTFSS	LED1				; IF LED WAS SWITCHED ON
	BSF		FLAGS,TEMPBIT	; ... YES, THEN SET LED FLAG
	BSF		LED1				; ALWAYS SWITCH LED OFF
		
	INCF		CLK_LED,F		; PREVENT NEXT LED TRANSITION TIME
	
	BSF		RFEN			; TURN ON RFEN FOR IN CASE WE ARE IN FSK MODE

	BTFSS	WSEL1			; IF EITHER OF THE WAKEUP SELECT
	BTFSC	WSEL0			; . BITS ARE SET FOR LONG WAKEUP
	GOTO	$+2				; ... THEN SKIP PREAMBLE ADJUSTMENT
	BSF		FLAGS,FIRST		; ... ELSE FORCE AS IF FIRST PREAMBLE SENT

; ***** SET NUMBER OF PREAMBLE PULSES AND VLOW THRESHOLD ***********

	MOVLW	D'11'			; LOAD THE NUMBER OF 16 PREAMBLE BITS - 1 = 15, 12 preamble bits for Genie
	BTFSS	FLAGS,FIRST		; IF FIRST LONG PREAMBLE NOT YET SENT
	MOVLW	D'1'				; ... THEN DO NOT DO EXTRA PULSES AFTER TIMEOUT
	MOVWF	CNT1			; STORE NUMBER OF PULSES TO TRANSMIT

	BTFSC	FLAGS,FIRST		; IF FIRST PREAMBLE ALREADY SENT
	BCF		WSEL1			; ... THEN USE NORMAL 50% DUTY CYLCE PULSES

	MOVLW	0				; FOR 100MS PREAMBLE DO NOT USE OFFSET
	BTFSS	WSEL1			; IF 75MS WAKEUP PREAMBLE SELECTED
	MOVLW	D'12'			; ... GET CONSTANT FOR 24.6MS OFFSET
	BTFSS	WSEL0			; IF 50MS WAKEUP PREAMBLE SELECTED
	MOVLW	D'24'			; ... GET CONSTANT FOR 50MS OFFSET

	BTFSS	FLAGS,FIRST		; IF NOT FIRST WAKEUP PREAMBLE
	ADDWF	TMR1H,F			; ... THEN ADD OFFSET TO CLOCK AND TEST WHEN 100MS REACHED
	CLRF	COMP			; INITIALIZE COMPENSATION
	BSF		COMP,2			; OVERHEAD COMPENSATION FOR LOOKING UP VLOW TRIP POINT
	CALL	TST_CLK			; UPDATE 50MS CLOCK
	CALL	TST_LED			; CHANGE LED PIN IF REQUIRED, RETURNS BAUD RATE AND C=0
	BSF		RFOUT			; SET RF OUTPUT HIGH
	CALL	TE_DEL05		; DO 1 TE DELAY
	CALL	VLOW_LEVEL		; GET VLOW LEVEL FROM LOOKUP TABLE

; ***** TEST VLOW AFTER WAITING AT LEAST 10 INSTRUCTION CYCLES ***********

	BSF		STATUS,RP0		; select Bank 1
	MOVWF	LVDCON			; (1) LOAD LOW VOLTAGE DETECT REGISTER
	MOVWF	VLOWLEVEL		; (6) STORE VALUE FOR COMPARISON
	BTFSS	LVDCON,IRVST
	GOTO	$-1
	BCF		STATUS,RP0
	BSF		FLAGS,VLOWBAT	; (11) FORCE VLOWBAT FLAG ON => ENSURE THAT LED DOESN'T SWITCH ON
	XORWF	VLOWLEVEL,F		; CHECK IF BATTERY LEVEL CHANGED
	RLF		VLOWLEVEL,F		; SET CARRY FLAG IF LEVEL CHANGED
	MOVWF	VLOWLEVEL		; STORE VLOW LEVEL
	BTFSS	VLOW			; IF VLOW NOT SET
	BCF		FLAGS,VLOWBAT	; ... THEN THE BATTERY IS OK, FLAG WAS SET EARLIER
	BCF		STATUS,RP0		; SELECT RAM BANK #0

	BTFSC	STATUS,C		; IF BATTERY LEVEL UNCHANGED
	BTFSS	VLOWL			; . OR VLOW LATCH DISABLED
	GOTO	TX_PRE1			; ... THEN SKIP VLOW LATCH UPDATE

; ***** UPDATE VLOW LATCH IN EEPROM ******************

	BCF		RFOUT			; STOP TRANSMITTER DURING EEWRITE
	BSF		STATUS,RP0		; SELECT RAM BANK #1
	MOVLW	EE_VLOWL		; GET OFFSET TO VLOW LATCH IN EEPROM
	MOVWF	EEADR			; SET EEPROM ADDRESS TO VLOW LATCH

	MOVLW	0FFH			; VALUE TO SET LATCH CHOOSEN TO BE SAME AS FAILED WRITE
	BTFSS	FLAGS,VLOWBAT	; IF NOT LOW BATTERY CONDITION	
	MOVLW	00H				; ... THEN CLEAR EEPROM LATCH
	CALL	EEWRITE			; UPDATE EEPROM LATCH
	BCF		STATUS,RP0		; SELECT RAM BANK #0

; ***** SEND TRANSMISSION'S PREAMBLE BITS ******************

TX_PRE1
	DECF	CLK_LED,F		; PERMIT NEXT LED TRANSITION TIME
	BTFSC	FLAGS,TEMPBIT	; IF THE LED WAS ON BEFORE THE VLOW CHECK
	BCF		LED1				; ... THEN SWITCH LED ON
TX_PRE2
	BCF		RFOUT			; CLEAR RF OUTPUT LOW
	MOVWF	CNT3			; LOAD LOOP COUNTER BUT NOT ON FIRST ITERATION
	GOTO	$+1
	
	BTFSS	WSEL1	 		; IF 50% DUTY CYCLE
	BCF		WSEL0			; ... THEN MAKE SURE WE DO NOT DO 16.7% DUTY CYCLE

	BSF		COMP,2			; OVERHEAD COMPENSATION FOR LOOKING UP VLOW TRIP POINT
	CALL	TE_DELAY		; DO 1 TE DELAY
	BTFSC	LEDL				; IF SINGLE LED BLINK ON VLOW IS ENABLED
	BCF		LED1				; ... YES, THEN SWITCH LED ON
	BCF		LEDL				; MARK THAT THE FIRST LED BLINK OCCURRED
	BTFSC	WSEL1	 		; IF 33.3% DUTY CYCLE
	CALL	TE_DELAY		; ... THEN WAIT ANOTHER TE
	BTFSC	WSEL0	 		; IF 16.6% DUTY CYCLE
	CALL	TE_DELAY		; ... THEN WAIT ANOTHER TE
	BTFSC	WSEL0	 		; IF 16.7% DUTY CYCLE
	CALL	TE_DELAY		; ... THEN WAIT ANOTHER TE
	BTFSC	WSEL0	 		; IF 16.7% DUTY CYCLE
	CALL	TE_DELAY		; ... THEN WAIT ANOTHER TE
	BSF		COMP,1			; TURN OUTPUT OFF WITH CORRECT CALIBRATION TIME
	BSF		RFOUT			; SET RF OUTPUT HIGH
	CALL	TE_DELAY		; DO 1 TE DELAY

	MOVLW	D'3'				; PRELOAD A HEADER OF 4xTE
	BTFSC	HSEL			; CHECK IF HEADER OPTION BIT IS SET
	MOVLW	D'9'				; ... YES, THEN USE A HEADER OF 10xTE

	BTFSS	CLK_50,1			; IF TIMED MODE COMPLETE SKIP TIME MODE TEST
	BTFSC	FLAGS,FIRST		; IF TIMED LONG PREAMBLE MODE
	DECFSZ	CNT1,F			; . OR NOT ALL PREAMBLE PULSES HAVE BEEN SENT
	GOTO	TX_PRE2			; ... THEN DO NEXT PULSE

; ***** SEND TRANSMISSION'S HEADER BITS ********************

	BSF		COMP,1			; TURN OUTPUT OFF WITH CORRECT CALIBRATION TIME
	BCF		RFOUT			; CLEAR RF OUTPUT LOW
	CALL	TE_DEL03		; DO 1 TE DELAY
TX_SYNC2
	BSF		COMP,1
	CALL	TE_DELAY		; DO 1 TE DELAY
	BSF		FLAGS,FIRST		; FLAG THAT FIRST PREAMBLE HAS BEEN SENT
	BSF		CSR6,0			; PRELOAD MANCHESTER/PPM START BIT INTO TRANSMIT BUFFER
	MOVLW	D'128'			; LOAD TOTAL NUMBER OF BITS TO TRANSMIT *2
	BTFSC	STRTSEL			; IF MANCHESTER/PPM START BIT REQUIRED
	MOVLW	D'130'			; ... THEN USE EXTRA START BIT
	DECFSZ	CNT3,F			; IF MORE HEADER TE CYCLES REQUIRED
	GOTO	TX_SYNC2		; ... THEN DO NEXT

; ***** SET TRANSMISSION'S LENGTH ( 32 HOP + 32 FIX ) ******

	CALL	TX_BITS			; SEND TRANSMISSION BITS

	MOVFW	FLAGS			; GET VLOW BIT IN LSB
	CALL	TX_1BIT			; SEND VLOW BIT

	BSF	CNT1,2				; PRELOAD TX BIT COUNTER FOR 2 BITS *2
	MOVFW	CRC				; GET CRC BITS
	CALL	TX_BITW			; SEND CRC BITS

	BSF	CNT1,2				; PRELOAD TX BIT COUNTER FOR 2 BITS *2
	MOVFW	QUEUE			; GET QUEUE BITS
	BTFSC	QUEN			; IF THE QUEUE COUNTER IS ENABLED
	CALL	TX_BITW			; SEND QUEUE BITS

	CLRF	CNT1
	BTFSC	STRTSEL			; IF MANCHESTER/PPM STOP BIT REQUIRED
	CALL	TX_BITH			; ... THEN SEND STOP BIT
	RETLW	0H

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: MAIN ()	      			
;
; DESCRIPTION  	: MAIN PROGRAM LOOP
;
; PAGE		: 0
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
MAIN:	
; ***** CONVERT BUTTON INPUTS TO FUNCTION CODE **************

	BCF		FLAGS,BUT_REL	; BUTTON NOT RELEASED YET

	MOVLW	0	
	MOVWF	CNT2		
	BTFSC	BUTTON,4		; if S1 is pressed
	BSF		CNT2,4			; ... then set cnt2 bit4=1
	BTFSC	BUTTON,0		; if S2 is pressed
	BSF		CNT2,5			; ... then set cnt2 bit5=1
	BTFSC	BUTTON,1		; if S1 is pressed
	BSF		CNT2,6			; ... then set cnt2 bit6=1	

; ***** ASK/FSK PLL ENABLE MODE OPTION ********************

	BTFSS	PLLSEL			; CHECK IF FSK MODE SELECTED
	BSF		RFEN			; SWITCH RFEN LINE ON IF IT IS AN OUTPUT 
	BTFSC	PLLSEL			; CHECK IF ASK MODE SELECTED
	BSF		RFOUT			; SET RF OUTPUT HIGH

; ***** INCREASE 16 BIT RAM SYNC COUNTER AND LOAD DISCRIMINATION BITS ***

	MOVFW	SYSCFG0			; GET COUNTER SELECT (16/20 BIT) OPTION
	CALL	CNTR_READ		; READ COUNTER, TEST LIMITED SEED, INCREMENT

; ***** ENCRYPT HOPCODE PORTION OF TRANSMISSION ************

	CALL	ENCRYPT0		; ENCRYPT COUNTER & DISCRIM VALUE WITH TX# KEY

; ***** LOAD SERIAL NUMBER AND FUNCTION CODE *****

	CALL	COPY_SER		; COPY TX# SERIAL NUMBER INTO TRANSMISSION BUFFER
	BTFSC	XSER			; IF THE EXTENDED SERIAL NUMBER OPTION IS NOT SET
	GOTO	M_SEED			; ... THEN SKIP INSERTING BUTTON CODE

	MOVLW	0FH				; MASK FOR UNENCRYPTED BUTTON CODE
	ANDWF	NSR7,W			; FORCE MSN OF SERIAL NUMBER TO ZERO
	IORWF	CNT2,W			; GET BUILD FUNCTION NIBBLE
	MOVWF	NSR7			; STORE READY TO TRANSMIT

; ***** SEND SEED TRANSMISSION INSTEAD OF HOPPING CODE *****

M_SEED
	BTFSS	FLAGS,SEEDNOW	; IF NOT SEED TRANSMISSION
	GOTO	M_START		; ... THEN SKIP LOADING SEED

M_SEED1
	BCF	FLAGS,DO_GUARD		; DO NOT WAIT FOR GUARD TIME ON FIRST SEED
	MOVLW	0F0H			; GET SEED OPTIONS MASK
	ANDWF	TX_CFG1,F		; CLEAR SEED OPTIONS TO PREVENT RELOADING SEED
	MOVLW	NSR7			; OFFSET OF SERIAL NUMBER IN CSR BUFFER
	MOVWF	FSR				; LOAD FILE SELECT REGISTER AND BANK #1
;	MOVLW	A_EE_SEED			; GET OFFSET OF SEED IN EEPROM
;   BTFSC	TX_INDEX,0
;	MOVLW	B_EE_SEED
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   A_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY1
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   B_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY1
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   C_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY1
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   D_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY1            
FIFY1    
	CALL	BLK_ADDR		; COPY FIRST 4 SEED BYTES INTO TX BUFFER
	CALL	BLK_NEXT		; COPY SECOND 4 SEED BYTES INTO TX BUFFER

	MOVLW	0F0H			; FORCE FUNC CODE TO BE 1111
	IORWF	NSR7,F			; COPY BUTTON CODE INTO CSR BUFFER

; ***** RESET TIMER AND STORE EVENT TIME AS LED TIME ON ****

M_START
	BCF		FLAGS,SEEDNOW	; MTX NOT COMPLETE, END OF SEED DETECT

; ***** SET THE MININUM NUMBER OF CODEWORDS ****************

	MOVLW	1H				; PRELOAD MINIMUM CODEWORDS WITH 1
	BTFSC	MTX1			; IF MSB OF MTX OPTION SET
	MOVLW	4H				; ... THEN PRELOAD MINIMUM CODEWORDS WITH 4
	MOVWF	CNT0			; LOAD LOOP COUNTER
	BTFSC	MTX0			; IF LSB OF MTX OPTION SET
	ADDWF	CNT0,F			; ... THEN DOUBLE THE COUNTER

; ***** RESET TIMERS ***************************************

	CLRF	TMR1L		; RESET REAL TIME CLOCK TO MARK LED SWITCH ON
	CLRF	TMR1H		; RESET REAL TIME CLOCK TO MARK LED SWITCH ON

	CLRF	CLK_50		; RESET 50MS CLOCK COUNTER
	CLRF	CLK_LED		; RESET LED FLASH CLOCK COUNTER
	CLRF	CLK_HI		; RESET 50MS OVERFLOW COUNTER

	MOVLW	D'48'		; SET 10MS TE LOW DEBOUNCE
	BTFSC	BSL1		; CHECK IF BSL1 BIT IS SET
	MOVLW	D'12'		; SET 10MS TE LOW DEBOUNCE
	MOVWF	CSR5
	BTFSS	BSL0		; CHECK IF BSL0 BIT IS SET
	ADDWF	CSR5,F		; YES, THEN FIX 5MS DEBOUNCE

M_TIME
	BTFSS	FLAGS,DO_GUARD	; IF FIRST TRANSMISSION NOT COMPLETED
	GOTO	M_TRANS		; ... THEN SKIP OVER GUARD TIME

; ***** SETUP GUARD TIME OUT PERIOD ************************

	BTFSC	GSEL1		; IF MSB OF GUARD SELECT BITS SET
	GOTO	M_GUARD	; ... THEN JUMP TO LONG PREAMBLE SECTION
	MOVLW	D'32'		; LOAD TIME OUT FOR 6.4MS
	BTFSC	GSEL0		; IF LSB OF GUARD SELECT BITS SET
	GOTO	M_GUARD1	; ... THEN WAIT FOR 32 x 200US = 6.4MS
	CALL	TE_DELAY	; WAIT FOR ONE RF TE CYCLE
	CALL	TE_DELAY	; WAIT FOR ONE RF TE CYCLE
	GOTO	M_TRANS	; JUMP OVER OTHER DELAY OPTIONS

M_GUARD
	MOVLW	0			; PRELOAD COUNTER FOR 245
	CALL	DLY_200US	; WAIT 256*200US = 51.2MS
	BTFSC	GSEL0		; IF LSB OF GUARD SELECT BITS SET
M_GUARD1
	CALL	DLY_200US	; WAIT ANOTHER 256*200US, TOTAL = 102.4MS


	MOVLW	D'8'			; DEFAULT DELAYED SEED TIME
	BTFSC	SDTM1		; IF MSB OF SDTM SET
	MOVLW	D'32'		; ... THEN DO 4X TE
	MOVWF	TEMP		; STORE TE MULTIPLIER TEMPORARILY
	BTFSC	SDTM0		; IF LSB OF SDTM SET
	ADDWF	TEMP,F		; ... THEN DOUBLE TE
	MOVFW	TEMP
	BCF		STATUS,C	; CLEAR CARRY BIT

	BTFSS	TEMP,3		; IF SDTM IS NOT 00
	SUBWF	CLK_50,W	; ... TEST IF CURRENT TIME GREATER THAN SEED TIME
	BTFSC	STATUS,C	; IF SDTM IS NOT 00 AND TIME IS > SEED TIME
	GOTO	M_SEED1		; ... THEN PREPARE AND SEND SEED

; ***** SEND TRANSMISSION OUT ON RFOUT PIN *****************

M_TRANS
	BSF	FLAGS,DO_GUARD	; MAKE SURE THAT WE DO A GUARD TIME ON FUTURE TX
	CALL	TRANSMIT	; SEND TRANSMISSION OUT ON RFOUT PIN
; ***** CHECK IF TRANSMISSION TIMEOUT REACHED **************

M_OUT1

	RLF	CLK_50,W		; GET THE 50MS CLOCK COUNTER * 2
	ANDLW	0F0H		; GET RID OF LOWER NIBBLE
	MOVWF	TEMP		; STORE IN TEMP REGISTER
	SWAPF	TEMP,F		; DIVIDE BY 16
	SWAPF	CLK_HI,W	; GET UPPER NIBBLE FROM OVERFLOW REGISTER
	IORWF	TEMP,F		; STORE NEW COUNTER OF 400MS TICKS SINCE POWERUP

	MOVLW 	2           		; .8S TIMEOUT
	BTFSC 	TSEL0		; 3.2S TIMEOUT
	MOVLW 	8
	SUBWF	TEMP,F
	
	MOVLW	30			; 12.8S TIMEOUT
	BTFSC	TSEL0		
	MOVLW   56			; 25.6S TIMEOUT

	SUBWF	TEMP,F

	BCF		RFOUT		; CLEAR RF OUTPUT LOW FOR VPWM

	BTFSS	TEMP,7		; IF TIMEOUT TIME REACHED (TEMP>=0)
	GOTO	M_SLEEP		; ... THEN TERMINATE TRANSMISSIONS
	NOP

M_QUE0
	BTFSC	BUTTON,7	; WAS THE DOUBLE PRESS BIT CLEAR
	BTFSS	QUEN		; . OR THE QUEUEING DISABLED
	GOTO	M_QUE2		; ... THEN FINISH MIN CODEWORDS

M_QUE
	bcf	FLAGS,DO_GUARD	; eliminate first guard time delay after new queue button

	BCF		BUTTON,7	; CLEAR THE DOUBLE PRESS BIT
	INCF		QUEUE,F		; INCREMENT QUEUE COUNTER
	BTFSC	QUEUE,2		; IF THE COUNTER > 3
	DECF	QUEUE,F		; ... THEN COUNTER = 3
	GOTO	MAIN		; DO THE NEXT SET OF CODEWORD TRANSMISSIONS

M_QUE2	
	DECFSZ	CNT0,F		; CHECK IF MININUM CODE WORDS COMPLETED
	GOTO	M_TIME		; ... NO, THEN SEND NEXT CODE WORD
;	BCF		BUTTON,7	; Clear the double press Button
	INCF		CNT0,F		; KEEP RECOGNIZING MTX COMPLETE NEXT LOOP

	BTFSC	SDMD		; IF IN PRODUCTION MODE AND SEED BUTTON AND COUNT<128
	GOTO	M_SEED1		; ... THEN PREPARE AND SEND SEED

	BTFSC	BUTTON,7	; IF DOUBLE PRESS BUT QUEUEING DISABLED
	GOTO	M_QUE		; ... THEN DO QUEUED TRANSMISSION NOW

	BTFSS	FLAGS,BUT_REL	; IF THE BUTTON IS STILL PRESSED
	GOTO	M_TIME		; ... THEN KEEP ON TRANSMITTING

	MOVFW	BUTTON		; GET BUTTON CODE TRANSMITTED
	BTFSS	STATUS,Z	; IF DOING LF CODE HOPPING COMMAND
	BTFSS	QUEN		; . OR QUEUEING IS DISABLED
	GOTO	M_SLEEP		; ... THEN SHUTDOWN THE DEVICE


	BCF		FLAGS,FIRST	; to do a new wake-up when queue buttons are after MTX

	MOVLW 1
	MOVWF	PORTA		; SWITCH LED AND STEP UP REGULATOR OFF
	BCF		RFEN		; TURN OFF RFEN
	MOVLW	D'192'		; SET UP 2 SECOND DELAY
	MOVWF	CNT0		;  COUNTER

M_QUE3
	CLRF	CNT2		; MAKE DELAY 10.4 MILLISECONDS
M_QUE4
	GOTO	$+1			; WASTE TIME
	DECFSZ	CNT2,1		; IF MORE LOOPS REQUIRED
	GOTO	M_QUE4		; ... THEN DO NEXT
	CALL	TE_DEL30	; CHECK FOR BUTTONS
	BTFSC	BUTTON,7	; IF DOUBLE BUTTON PRESS
	GOTO	M_QUE0		; ... THEN GOTO STOP LOOPING

	DECFSZ	CNT0,F		; IF MORE LOOPS REQUIRED
	GOTO	M_QUE3		; ... THEN KEEP ON LOOPING

; ***** ENTER SLEEP/SHUTDOWN MODE **************************

M_SLEEP
	bsf		LED1			; SWITCH LED OFF
	bcf		RFEN		; SWITCH RFEN OFF
	MOVFW	PORTA		; MAKE SLEEP OUTPUT HIGH, SETUP WAKEUP LATCHES
	bcf		INTCON,RAIF
	bsf		INTCON,RAIE

	sleep
	nop

	bcf		INTCON,RAIF
	bcf		INTCON,RAIE

	goto	RESET


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
; PAGE #1
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;	ORG	200H

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: COPY_SER ()	      			
;
; DESCRIPTION  	: COPY SERIAL NUMBER IN TRANSMISSION BUFFER
;
; PAGE		: 1
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
COPY_SER
	MOVLW	NSR7			; OFFSET OF SERIAL NUMBER IN CSR BUFFER
	MOVWF	FSR				; LOAD FILE SELECT REGISTER
;	MOVLW	A_EE_SER			; GET OFFSET OF SERIAL NUMBER IN EEPROM
;	BTFSC	FLAGS,TX_NUM 	; VERIFY IF WE NEED FIRST OR SECOND TRANSMITTER
;    BTFSC	TX_INDEX,0
;	MOVLW 	B_EE_SER		; INFORMATION
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   A_EE_SER
    BTFSC   STATUS,Z
    GOTO    FIFY2
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   B_EE_SER
    BTFSC   STATUS,Z
    GOTO    FIFY2
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   C_EE_SER
    BTFSC   STATUS,Z
    GOTO    FIFY2
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   D_EE_SER
    BTFSC   STATUS,Z
    GOTO    FIFY2            
FIFY2 
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: BLK_READ ()	      			
;
; DESCRIPTION  	: READ BLOCK OF UP TO 4 BYTES OF DATA FROM EEPROM
;
; PAGE		: 1
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
BLK_ADDR

BLK_READ
	BSF		STATUS,RP0	; Select Bank 1
	MOVWF	EEADR		; SET EEPROM ADDRESS POINTER

BLK_NEXT
	CALL	EEREAD		; READ BYTE FROM EEPROM
	MOVWF	INDF			; COPY INTO REQUIRED BUFFER
	DECF	FSR,F		; POINT TO NEXT BYTE IN BUFFER
	BTFSC	FSR,0		; IF NOT YET AT A
	BTFSS	FSR,1		; . 4 BYTE BOUNDARY
	GOTO	BLK_NEXT	; ... THEN READ NEXT BYTE
	RETLW	0

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: EEREAD ()	      			
;
; DESCRIPTION  	: READ 8 BIT VALUE FROM INTERNAL EEPROM 
;
; PAGE		: 1
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
EEREAD1

EEREAD0
	BSF		STATUS,RP0	; Select Bank 1
	MOVWF	EEADR		; SET EEPROM ADDRESS POINTER

EEREAD
	BSF		STATUS,RP0	; Select Bank 1
	BSF		EECON1,RD	; Command read
	INCF		EEADR,F		; POINT TO NEXT ENTRY IN EEPROM
	MOVFW	EEDATA		; GET THE VALUE READ FROM EEPROM
	BCF		STATUS,RP0	; Select Bank 0
	RETURN				; RETURN 

SETTX0
	BSF		STATUS,RP0		; SELECT RAM BANK #1
	MOVLW	EE_TX_INDEX
	MOVWF	EEADR
	MOVLW	0H
	MOVWF	TX_INDEX
	CALL	EEWRITE
	BCF		STATUS,RP0		; SELECT RAM BANK #0	
	RETURN

TX_INDEX_INC
	BSF		STATUS,RP0		; SELECT RAM BANK #1
	INCF	TX_INDEX,F
	BTFSC	TX_INDEX,2
	CLRF	TX_INDEX
	MOVLW	EE_TX_INDEX
	MOVWF	EEADR
	MOVFW	TX_INDEX
	CALL	EEWRITE
	BCF		STATUS,RP0		; SELECT RAM BANK #0	
	GOTO	M_SLEEP
;	RETURN
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: EEWRITE ()	      			
;
; DESCRIPTION  	: WRITE 8 BIT VALUE TO INTERNAL EEPROM 
;
; PAGE		: 1
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
EEWRITEI
	BSF		STATUS,RP0	; Select Bank 1
	BSF		FSR,5		; POINT TO DATA EEPROM
	MOVFW	INDF			; GET DATA AT INDIRECT POINTER
	DECF	EEADR,F		; FIX EEPROM ADDRESS FROM LAST INCREMENT

EEWRITE
	BSF		STATUS,RP0		; Select Bank 1
	MOVWF	EEDATA			; STORE NEW VALUE IN EEPROM DATA REGISTER
	BSF		EECON1,WREN	; Command Write Enable
	MOVLW	55H
	MOVWF	EECON2			; Write 55H
	MOVLW	0AAH
	MOVWF	EECON2			; Write AAH
	BSF		EECON1,WR		; Command Write

WR_WAIT
	CLRWDT
	BTFSC	EECON1,WR		; Wait for write to complete
	GOTO	WR_WAIT
	BCF		EECON1,WREN	; Disable writes
	INCF		EEADR,F			; POINT TO NEXT ADDRESS IN EEPROM
	BCF		STATUS,RP0		; Select Bank 0
	RETLW	0H


;;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;;
;; FUNCTION     	: Encrypt ()	      			
;;
;; DESCRIPTION  	: Contains encryption routine
;;
;;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

	#include Encrypt.inc

;;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;;
;; FUNCTION     	: CounterCode ()	      			
;;
;; DESCRIPTION  	: Loads, increments and verifies counter value
;;
;;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

	#include CounterCode.inc


;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: DEBOUNCER ()
;
; DESCRIPTION  	: LOAD SYSTEM CONFIG, DEBOUNCE INPUTS, LOAD TRANSMITTER CONFIG
;
; PAGE		: 1
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
DEBOUNCER

; ****** LOAD SYSTEM CONIGURATION FROM EEPROM *********************************

	MOVLW	EE_CFG2		; OFFSET OF LOWER BYTE OF SYSTEM CONFIG #1
	CALL	EEREAD0		; READ BYTE FROM EEPROM
	ANDLW	3FH			; MASK OUT LOWER 6 BITS
	MOVWF	SYSCFG1		; LOAD SYSTEM CONFIGURATION OPTIONS #1

	MOVLW	EE_CFG0		; OFFSET OF LOWER BYTE OF SYSTEM CONFIG #0
	CALL	EEREAD0		; READ BYTE FROM EEPROM
	ANDLW	3FH			; MASK OUT LOWER 6 BITS
	MOVWF	SYSCFG0		; LOAD SYSTEM CONFIGURATION OPTIONS #0

	MOVLW	EE_TX_INDEX
	CALL	EEREAD0
	MOVWF	TX_INDEX
	XORLW	0FFH
	BTFSC	STATUS,Z
	CALL	SETTX0

; ***** SETUP FUNCTION CODE BUTTON MASK REGISTER ***********

	BTFSS	RFENSEL		; IF RFEN SELECTED
	GOTO	$+3
	BSF		STATUS,RP0
	BCF		RFENtris		; ... THEN MAKE RFEN AN OUTPUT
	BSF		STATUS,RP0
	MOVFW	TRISA
	BCF		STATUS,RP0
	BTFSC	INDSEL		; IF SHIFT INPUT ENABLED
	ANDLW	B'00010011'	; ... THEN REMOVE SHIFT INPUT FROM BUTTON MASK
	MOVWF	B_MASK		; LOAD BUTTON MASK REGISTER

; ****** CHECK FOR 20MS DEBOUNCE TIME ********

	MOVLW	3FH			; COMPENSATE FOR WAKEUP TIME & OVERHEAD = 6x8 = 48us
	MOVWF	TMR1L		; LOAD RTCC COUNTER WITH 3636H
	MOVWF	TMR1H		; TO SIMPLIFY 20MS TEST AT 4000H WITH ONLY .2% ERROR

; ****** DEBOUNCE BUTTON INPUTS *****************************************

DEBOUNCE1
	CALL	EEREAD		; DELAY WHILE UPDATING DC/DC OUTPUTS
	BTFSS	TMR1H,6		; CHECK IF WE REACHED 20MS BUTTON DEBOUNCE TIMEOUT
	GOTO	DEBOUNCE1	; ... NO, THEN CONTINUE WAITING

	CLRF	FLAGS		; START WITH ALL FLAGS CLEARED
IFDEF pullup
	BTFSS	SHIFT
ELSE
	BTFSC	SHIFT			; IF SHIFT BUTTON PRESSED
ENDIF
;	BSF		FLAGS,TX_NUM	; ... THEN SAVE SELECTION
	CALL	TX_INDEX_INC

	BTFSS	RFENSEL			; IF RFEN OUTPUT ENABLED
	BTFSS	INDSEL			; . OR NOT DUAL TRANSMITTER 
;	BCF		FLAGS,TX_NUM	; ... THEN FORCE TO FIRST TRANSMITTER
	CALL	SETTX0

IFDEF pullup
	COMF	PORTA,w
ELSE
	MOVFW	PORTA			; [1/1] READ GENERAL I/O 
ENDIF
	ANDWF	B_MASK,W		; MASK OUT THE FUNCTION CODE, SET Z IF NO BUTTON
	MOVWF	BUTTON			; STORE BUTTON CODE IN TEMP REGISTER

; ****** LOAD SYSTEM CONIGURATION FROM EEPROM *********************************

;	MOVLW	A_EE_DISC		; OFFSET OF LOWER BYTE OF TX0'S CONFIGURATION
;	BTFSC	FLAGS,TX_NUM
;    BTFSC	TX_INDEX,0
;	MOVLW	B_EE_DISC
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   A_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY3
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   B_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY3
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   C_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY3
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   D_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY3            
FIFY3   
	CALL	EEREAD1		; READ BYTE FROM EEPROM
	BSF		STATUS,RP0
	RRF		EEDATA,F	; ROTATE BYTE READ FROM EEPROM
	RRF		EEDATA,W	; ROTATE BYTE READ FROM EEPROM
	BCF		STATUS,RP0
	ANDLW	03FH		; MASK OUT LOWER 6 BITS FROM BYTE
	MOVWF	TX_CFG0		; LOAD TRANSMITTER CONFIGURATION OPTIONS #1

;	MOVLW	EE_CFG0		; OFFSET OF LOWER BYTE OF TX0'S CONFIGURATION
;	BTFSC	FLAGS,TX_NUM	; CHECK IF SECOND TRANSMITTER IS SELECTED
;    BTFSC	TX_INDEX,0
;	MOVLW	EE_CFG2		; ... YES, THEN USE TX1'S CONFIGURATION
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   EE_CFG0
    BTFSC   STATUS,Z
    GOTO    FIFY4
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   EE_CFG2
    BTFSC   STATUS,Z
    GOTO    FIFY4
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   EE_CFG0
    BTFSC   STATUS,Z
    GOTO    FIFY4
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   EE_CFG2
    BTFSC   STATUS,Z
    GOTO    FIFY4            
FIFY4 
	CALL	EEREAD0		; READ BYTE FROM EEPROM
	ANDLW	0C0H		; MASK OUT UPPER 2 BITS FROM BYTE
	IORWF	TX_CFG0,F	; COPY INT TRANSMITTER CONFIGURATION OPTIONS #0

;	MOVLW	EE_CFG3		; OFFSET OF LOWER BYTE OF TX0'S CONFIGURATION
;	BTFSC	FLAGS,TX_NUM	; CHECK IF SECOND TRANSMITTER IS SELECTED
;    BTFSC	TX_INDEX,0
;	MOVLW	EE_CFG1		; ... YES, THEN USE TX1'S CONFIGURATION
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   EE_CFG3
    BTFSC   STATUS,Z
    GOTO    FIFY5
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   EE_CFG1
    BTFSC   STATUS,Z
    GOTO    FIFY5
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   EE_TX2_CFG1
    BTFSC   STATUS,Z
    GOTO    FIFY5
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   EE_TX3_CFG1
    BTFSC   STATUS,Z
    GOTO    FIFY5            
FIFY5
	CALL	EEREAD0		; READ BYTE FROM EEPROM
	MOVWF	TX_CFG1		; LOAD TRANSMITTER CONFIGURATION OPTIONS #1
	
;	MOVLW	A_EE_SEED		; OFFSET OF UPPER BYTE OF SEED TRANSMISSION
;	BTFSC	FLAGS,TX_NUM
;    BTFSC	TX_INDEX,0
;	MOVLW	B_EE_SEED
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   A_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY6
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   B_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY6
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   C_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY6
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   D_EE_SEED
    BTFSC   STATUS,Z
    GOTO    FIFY6            
FIFY6
	CALL	EEREAD1		; READ BYTE FROM EEPROM

	MOVFW	BUTTON		; GET BUTTON PRESSED
	ANDWF	B_MASK,W	; MASK OUT THE FUNCTION CODE, SET Z IF NO BUTTON
	
	BTFSC	STATUS,Z	; IF NO BUTTON PRESSED
	GOTO	M_SLEEP		; ... THEN RETURN TO SLEEP MODE

; ***** CHECK IF A SEED TRANSMISSION IS REQUIRED ***********

XmitNOW
	BSF		STATUS,RP0
	SWAPF	EEDATA,W		; GET BYTE READ FROM EEPROM
	BCF		STATUS,RP0
	ANDLW	0FH				; MASK SEED BITS OUT OF BUTTON CODE

	XORWF	BUTTON,W		; COMPARE WITH BUTTON PRESSED

	MOVLW	0F0H			; GET SEED OPTIONS MASK
	BTFSS	STATUS,Z		; IF NOT CORRECT BUTTON PRESS
	ANDWF	TX_CFG1,F		; ... THEN CLEAR SEED OPTIONS
	BTFSC	STATUS,Z		; ELSE
	BSF		FLAGS,SEEDNOW	;... SET SEND SEED TRANSIMISSION NOW FLAG

	BTFSS	SDTM0			; IF DELAYED SEED ENABLED WITH EITHER
	BTFSC	SDTM1			; . OF THE DELAY SEED BITS
	BCF		FLAGS,SEEDNOW	; ... THEN STOP SEED TX NOW

	BTFSC	SDMD			; IF PRODUCTION SEED MODE ENABLED
	BCF		FLAGS,SEEDNOW	; ... THEN STOP SEED TX NOW
	BSF		FLAGS,BUT_DWN	; SET BUTTON PRESSED FLAG
	BSF		FLAGS,VLOWBAT	; DISABLE LED UNTIL AFTER VLOW TEST
	
	CLRF	QUEUE

	GOTO	MAIN		; START MAIN LOOP



;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; END OF FILE : KLQ_PIC16F636.ASM
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
	END


