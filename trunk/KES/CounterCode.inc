;*************************************************************************************************
;CODE OWNERSHIP AND DISCLAIMER OF LIABILITY
;
;Microchip Technology Incorporated ("Microchip") retains all ownership and intellectual property rights in the code accompanying 
;this message and in all derivatives hereto.  You may use this code, and any derivatives created by any person or entity by or on 
;your behalf, exclusively with Microchip’s proprietary products.  Your acceptance and/or use of this code constitutes agreement to 
;the terms and conditions of this notice.
;
;CODE ACCOMPANYING THIS MESSAGE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR 
;STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS 
;FOR A PARTICULAR PURPOSE APPLY TO THIS CODE, ITS INTERACTION WITH MICROCHIP’S PRODUCTS, COMBINATION WITH ANY 
;OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
;
;YOU ACKNOWLEDGE AND AGREE THAT, IN NO EVENT, SHALL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY, TORT 
;(INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR 
;ANY INDIRECT, SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY 
;KIND WHATSOEVER RELATED TO THE CODE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY 
;OR THE DAMAGES ARE FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
;CLAIMS IN ANY WAY RELATED TO THIS CODE, SHALL NOT EXCEED THE PRICE YOU PAID DIRECTLY TO MICROCHIP SPECIFICALLY TO
;HAVE THIS CODE DEVELOPED.
;
;You agree that you are solely responsible for testing the code and determining its suitability.  Microchip has no obligation to modify, 
;test, certify, or support the code.
;***************************************************************************************************

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FUNCTION     	: CNTR_READ ()	      			
;
; DESCRIPTION  	: READ AND FIX EEPROM SYNC COUNTER, CONVERT TO BINARY, CHECK IF < 128 
;
; PAGE		: 1
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
GRAY2B	
	BTFSC	COUNTA,0	; CONVERT PSEUDO GRAY CODE TO BINARY
	COMF	COUNTB,F	; BY INVERTING BYTES IF THE HIGHER ORDER
	BTFSC	COUNTB,0	; BYTE IS ODD, THE SEQUENCE IS CRITICAL
	COMF	COUNTC,F	; FOR ODD BITS TO RIPPLE THROUGH COUNTER
	RETLW	0

CNTR_READ
	MOVWF	CNT1		; STORE SYSCFG0 FOR EASY ACCESS FROM RAM BANK #2
	MOVLW	COUNTA		; OFFSET OF SERIAL NUMBER IN CSR BUFFER
	MOVWF	FSR			; LOAD FILE SELECT REGISTER
;	MOVLW	EE_CNT0		; GET OFFSET OF TX0'S FIRST COUNTER IN EEPROM
;	BTFSC	FLAGS,TX_NUM	; CHECK IF SECOND TRANSMITTER IS SELECTED
;    BTFSC	TX_INDEX,0
;	MOVLW	EE_CNT1		; ... THEN USE TX1'S FIRST COUNTER
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   EE_CNT0
    BTFSC   STATUS,Z
    GOTO    FIFY8
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   EE_CNT1
    BTFSC   STATUS,Z
    GOTO    FIFY8
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   EE_CNT2
    BTFSC   STATUS,Z
    GOTO    FIFY8
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   EE_CNT3
    BTFSC   STATUS,Z
    GOTO    FIFY8            
FIFY8
	CALL	BLK_READ	; READ 2 BYTES OF COUNTER BLOCK FROM EEPROM
	CALL	BLK_NEXT	; READ NEXT 4 BYTE BLOCK FROM EEPROM

;*** TEST 3 BYTE CHECKSUM FOR ALL 8 BIT AND MOST OTHER ERRORS ***

	MOVFW	CHECKBC		; IF THE XOR
	XORWF	CHECKAC,W	; OF THE THREE
	XORWF	CHECKAB,W	; CHECKSUM BYTES
	BTFSS	STATUS,Z	; IS NOT ZERO
	GOTO	CNTR_INC2	; ... THEN REWRITE THEM

;*** ASSUME CHECKSUM OK AND TEST MSB FOR ERRORS ***

	MOVFW	COUNTB		; IF THE XOR
	XORWF	COUNTC,W	; OF THE MIDDLE, LSB
	XORWF	CHECKBC,W	; AND CHECKSUM BYTES
	BTFSS	STATUS,Z	; IS NOT ZERO
	GOTO	CNTR_INC3	; ... THEN ASSUME MSB OK AND FIX THE REST

;*** ASSUME MSB MAY BE INCORRECT AND RECALCULATE FROM CHECKSUMS ***

	MOVFW	CHECKAB		; THE XOR OF THE CHECKSUM
	XORWF	COUNTB,W	; AND ANOTHER GOOD BYTE
	XORWF	COUNTA,F	; IF IT MATCHES THE ZERO FLAG
	MOVWF	COUNTA		; RESTORE THE VALUE IF THE MSB
	BTFSS	STATUS,Z	; IF THERE WAS AN ERROR IN MSB
	GOTO	CNTR_INC4	; ... THEN DO NOT INCREMENT, GOTO FIX ERROR

;*** CONVERT PSEUDO GRAY CODE TO BINARY ***

	CALL	GRAY2B		; CONVERT GRAY CODE TO BINARY

	RLF		COUNTC,W	; GET BIT 7 INTO CARRY TO CHECK IF COUNT>127
	RLF		COUNTA,W	; GET MSB OF COUNTER WITH EXTRA ROLLOVER
	ANDLW	3FH			; MASK TO ELIMINATE EXTRA BITS IN MSB
	IORWF	COUNTB,W	; OR IT WITH THE MIDDLE BYTE OF THE COUNTER
	BTFSC	STATUS,Z	; IF THE TOP 14 BITS OF THE COUNTER ARE ZERO
	GOTO	CNTR_INC	; ... THEN INCREMENT COUNTER

	BCF		FSR,5		; SELECT RAM BANK #0
	BTFSC	SDLM		; IF LIMITED SEED ENABLED
	BCF		FLAGS,SEEDNOW	; ... CLEAR SEED TX NOW FLAG
	MOVLW	0F0H		; GET SEED OPTIONS MASK
	BTFSC	SDLM		; IF LIMITED SEED ENABLED
	ANDWF	TX_CFG1,F	; ... THEN CLEAR SEED OPTIONS
	BCF		SDMD		; CLEAR PRODUCTION MODE FLAG
	BSF		FSR,5		; SELECT RAM BANK #1

;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; MEMORY MAP	:	EEPROM	NAME	RAM	DESCRIPTION
;			00	COUNTA	NSR5	COUNTER BITS 21-16 MSB
;			01	COUNTB	NSR4	COUNTER BITS 15-8
;			02	COUNTC	NSR3	COUNTER BITS 7-0 LSB
;			03	CHECKBC	NSR2	B XOR C CHECKSUM
;			04	CHECKAB	NSR1	A XOR B CHECKSUM
;			05	CHECKAC	NSR0	A XOR C	CHECKSUM
;
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
CNTR_INC
	BTFSC	FLAGS,SEEDNOW	; IF A SEED TRANSMISSION IS REQUIRED
	RETLW	0				; ... RETURN INSTEAD OF INCREMENTING COUNTER
	INCF		COUNTC,F		; DO THE 24 BIT BINARY INCREMENT
	BTFSC	STATUS,Z		; THE CARRY RIPPLES UP TO HIGHEST ORDER BYTE
	INCF		COUNTB,F		;
	BTFSC	STATUS,Z		; IF NO ROLLOVER YET
	INCF		COUNTA,F		; ... THEN INCREMENT 4 BIT MSB / 6 BIT OVR
	BTFSC	COUNTA,5		; IF 20 BIT COUNTER ROLLS OVER
	BSF		COUNTA,4		; ... THEN FORCE ROLL OVER FLAG SET
	BCF		COUNTA,5		; CLEAR ROLL OVER DETECT FLAG

	BTFSC	COUNTB,0		; CONVERT BINARY TO PSEUDO GRAY CODE
	COMF	COUNTC,F		; BY INVERTING BYTES IF THE HIGHER ORDER
	BTFSC	COUNTA,0		; BYTE IS ODD, THE SEQUENCE IS REVERSED
	COMF	COUNTB,F		; BECAUSE THE INCREMENT ALREADY RIPPLED UP

;*** RECALCULATE THE CHECKSUMS ***
CNTR_INC2	
	MOVFW	COUNTA		; A XOR B => CHECKAB
	XORWF	COUNTB,W
	MOVWF	CHECKAB
	MOVFW	COUNTA		; A XOR C => CHECKAC
	XORWF	COUNTC,W
	MOVWF	CHECKAC
	MOVFW	COUNTB		; B XOR C => CHECKBC
	XORWF	COUNTC,W
	MOVWF	CHECKBC

;*** ASSUME MIDDLE OR LSB INCORRECT AND RECALCULATE FROM CHECKSUMS ***
CNTR_INC3
	MOVFW	COUNTA		; THE XOR OF THE MSB
	XORWF	CHECKAB,W	; AND THE CHECKSUM
	MOVWF	COUNTB		; RESTORES THE MIDDLE BYTE
	XORWF	CHECKBC,W	; WHICH XORED WITH THE CHECKSUM
	MOVWF	COUNTC		; RESTORES THE LSB

;*** WRITE MODIFIED LOCATIONS TO DATA EEPROM ***
CNTR_INC4
	MOVLW	COUNTA		; OFFSET OF SERIAL NUMBER IN CSR BUFFER
	MOVWF	FSR		; INITIALIZE COMPARISON POINTER
;	MOVLW	EE_CNT0		; GET OFFSET OF TX0'S FIRST COUNTER IN EEPROM
;	BTFSC	FLAGS,TX_NUM	; CHECK IF SECOND TRANSMITTER IS SELECTED
;    BTFSC	TX_INDEX,0
;	MOVLW	EE_CNT1		; ... THEN USE TX1'S FIRST COUNTER
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   EE_CNT0
    BTFSC   STATUS,Z
    GOTO    FIFY9
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   EE_CNT1
    BTFSC   STATUS,Z
    GOTO    FIFY9
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   EE_CNT2
    BTFSC   STATUS,Z
    GOTO    FIFY9
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   EE_CNT3
    BTFSC   STATUS,Z
    GOTO    FIFY9            
FIFY9
	CALL	EEREAD0		; READ FIRST BYTE FROM EEPROM
CNTR_INC5
	XORWF	INDF,W		; COMPARE WITH NEW COUNTER VALUES
	BTFSS	STATUS,Z	; IF BYTES ARE NOT EQUAL
	CALL	EEWRITEI	; ... THEN UPDATE DATA EEPROM LOCATION

	CALL	EEREAD		; READ NEXT BYTE FROM EEPROM
	DECF	FSR,F		; POINT TO NEXT LOCATION
	BTFSC	FSR,3		; LOOP THROUGH ENTIRE COUNTER BLOCK
	GOTO	CNTR_INC5

	CALL	GRAY2B		; CONVERT GRAY CODE TO BINARY

;*** INSERT DISCRIMINATION BITS AND 16 BIT COUNTER OVERFLOW BITS ***

	MOVFW	COUNTC		; GET MSB OF COUNTER A
	MOVWF	NSR0		; STORE MSB A IN POSITION TO ENCRYPT
	MOVFW	COUNTB		; GET MSB OF COUNTER A
	MOVWF	NSR1		; STORE MSB A IN POSITION TO ENCRYPT
	MOVFW	COUNTA		; GET MSB OF COUNTER A
	MOVWF	NSR2		; STORE MSB A IN POSITION TO ENCRYPT

	ANDLW	1EH			; MASK TO GET COUNTER ROLLOVER BITS
	MOVLW	0CH			; DEFAULT THAT NO OVERFLOW HAS OCCURED
	BTFSS	STATUS,Z	; IF ANY UPPER BIT IN THE COUNTER IS SET (2+ ROLLOVERS)
	MOVLW	00H			; ... THEN CLEAR BOTH OVERFLOW BITS
	BTFSC	NSR2,0		; IF COUNTER BIT 17 SET (1+ ROLLOVERS)
	ANDLW	0FBH		; ... THEN CLEAR THE LOWER OVERFLOW BIT
	MOVWF	NSR3		; STORE OVERFLOW BITS

	MOVLW	0FH			; MASK OUT LOWER 4 BITS OF 20 BIT COUNTER
	ANDWF	NSR2,F		; CLEAR BITS TO INSERT DISCRIMINATION VALUE 

;	MOVLW	A_EE_DISC		; GET OFFSET OF DISCRIMINATION VALUE IN EEPROM
;	BTFSC	FLAGS,TX_NUM	; CHECK IF SECOND TRANSMITTER IS SELECTED
;    BTFSC	TX_INDEX,0
;	MOVLW	B_EE_DISC		; ... THEN USE TX1'S FIRST COUNTER	
    MOVFW   TX_INDEX
    XORLW   00H
    MOVLW   A_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY10
    MOVFW   TX_INDEX
    XORLW   01H
    MOVLW   A_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY10
    MOVFW   TX_INDEX
    XORLW   02H
    MOVLW   A_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY10
    MOVFW   TX_INDEX
    XORLW   03H
    MOVLW   A_EE_DISC
    BTFSC   STATUS,Z
    GOTO    FIFY10            
FIFY10
	CALL	EEREAD1		; READ BYTE FROM EEPROM
 	ANDLW	03H			; MASK OUT THE DISCRIMINATION BITS
	IORWF	NSR3,F		; STORE AS UPPER 2 BITS OF DISCRIM
	CALL	EEREAD		; READ NEXT BYTE FROM EEPROM

	BTFSS	CNTSEL		; CHECK IF 20 BIT COUNTER MODE SELECTED (CNTSEL)
	GOTO	CNTR_INC6	; ... NO, THEN COPY OVR BITS INTO ENC FUNC BYTE

	MOVWF	NSR3		; STORE DISCRIM BITS
	SWAPF	NSR3,F		; ROTATE DISCRIM BYTE 4 BITS LEFT FOR 20 BIT COUNTER
	MOVFW	NSR3		; GET 4 LEAST SIGNIFICANT BITS OF DISCRIM
	ANDLW	0F0H		; CLEAR THE BITS IN THE COUNTER'S POSITION
	IORWF	NSR2,W		; OR THE DISCRIMINATION VALUE INTO THE COUNTER REG

CNTR_INC6				; MOVED HERE FROM GET_DISC TO KEEP WAKEUP CALLABLE
	MOVWF	NSR2		; STORE AS LOWER 8 BITS OF DISCRIM

	MOVLW	0FH				; GET MASK TO REMOVE UPPER 4 BITS
	ANDWF	NSR3,F			; CLEAR BITS FOR FUTURE INSERTION OF FUNCTION CODE
	MOVFW	CNT2			; GET THE BUTTON CODE
	IORWF	NSR3,F			; ADD THE BUTTON CODE TO BE ENCRYPTED
	BCF		FLAGS,SEEDNOW	; CLEAR SEED TX NOW FLAG WHEN FIXING COUNTER
	RETLW	0H				; RETURN WITH COUNTER AND DISCRIMINATION LOADED

